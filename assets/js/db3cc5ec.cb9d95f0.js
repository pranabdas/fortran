"use strict";(self.webpackChunkfortran_programing=self.webpackChunkfortran_programing||[]).push([[10],{8468:function(n,r,a){a.r(r),a.d(r,{assets:function(){return E},contentTitle:function(){return u},default:function(){return m},frontMatter:function(){return c},metadata:function(){return s},toc:function(){return p}});var t=a(7462),e=a(3366),i=(a(7294),a(3905)),o=a(5710),l=["components"],c={title:"Array and Matrix"},u=void 0,s={unversionedId:"array",id:"array",title:"Array and Matrix",description:"There is intrinsic SIZE function to determine the length of a vector, SIZE(vec).",source:"@site/docs/array.mdx",sourceDirName:".",slug:"/array",permalink:"/fortran/array",draft:!1,editUrl:"https://github.com/pranabdas/fortran/blob/main/docs/array.mdx",tags:[],version:"current",frontMatter:{title:"Array and Matrix"},sidebar:"docs",previous:{title:"Basics",permalink:"/fortran/basics"},next:{title:"Logical control",permalink:"/fortran/control"}},E={},p=[],N={toc:p};function m(n){var r=n.components,a=(0,e.Z)(n,l);return(0,i.kt)("wrapper",(0,t.Z)({},N,a,{components:r,mdxType:"MDXLayout"}),(0,i.kt)(o.Z,{language:"fortran",title:"src/05_array.f90",showLineNumbers:!0,mdxType:"CodeBlock"},"! Program : Array\n\nPROGRAM array\n  IMPLICIT NONE\n\n  INTEGER :: vec(10)\n  INTEGER :: ii\n\n  OUTER_LOOP : DO ii = 1, 10\n    vec(ii) = ii\n  ENDDO OUTER_LOOP\n\n  DO ii = 1, 10\n    PRINT '(i2)', vec(ii)\n  ENDDO\n\nEND PROGRAM array\n"),(0,i.kt)("p",null,"There is intrinsic SIZE function to determine the length of a vector, SIZE(vec).\nAnother example where we use implied DO loop to assign an array:"),(0,i.kt)(o.Z,{language:"fortran",title:"src/05_array2.f90",showLineNumbers:!0,mdxType:"CodeBlock"},"PROGRAM array2\n    IMPLICIT NONE\n\n    INTEGER, DIMENSION(10) :: vec\n    INTEGER :: ii\n\n    vec = [(ii, ii = 1, 10)]\n\n    DO ii = 1, SIZE(vec)\n      PRINT '(i2)', vec(ii)\n    ENDDO\n\nEND PROGRAM array2\n"),(0,i.kt)("p",null,"Dynamic array allocation with ALLOCATABLE:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-fortran"},"INTEGER, DIMENSION(:), ALLOCATABLE :: a\nINTEGER i\na = [(i, i = 1, 10)]\n")),(0,i.kt)("p",null,"Assign high dimensional array with RESHAPE:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-fortran"},"a = RESHAPE([1, 2, 3, 4, 5, 6], [2, 3])\n! will produce\n! 1 3 5\n! 2 4 6\n\na = RESHAPE([1, 2, 3, 4, 5, 6], [2, 3], order=[2, 1])\n! will produce\n! 1 2 3\n! 4 5 6\n")),(0,i.kt)("p",null,"Matrix multiplication:"),(0,i.kt)(o.Z,{language:"fortran",title:"src/05_matrix_mult.f90",showLineNumbers:!0,mdxType:"CodeBlock"},"! Program : Matrix multiplication\n\nPROGRAM matrix_mult\n  IMPLICIT NONE\n\n  INTEGER, DIMENSION(2, 3) :: A = RESHAPE([1, 2, 3, &\n                                           4, 5, 6], &\n                                           shape(A), &\n                                           order=[2, 1])\n\n  INTEGER, DIMENSION(3, 2) :: B = RESHAPE([1, 2, &\n                                           3, 4, &\n                                           5, 6], &\n                                           shape(B), &\n                                           order=[2, 1])\n\n  INTEGER, DIMENSION(2, 2) :: output\n  INTEGER :: ii\n\n  output = MATMUL(A, B)\n\n  DO ii = 1, 2\n    PRINT *, output(ii, :)\n  END DO\nEND PROGRAM matrix_mult\n"),(0,i.kt)("p",null,"You can assign all the array element same value by assigning it a scaler value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-fortran"},"INTEGER, DIMENSION(2, 2) :: a\na = 1\n! will produce\n! 1 1\n! 1 1\n")))}m.isMDXComponent=!0}}]);