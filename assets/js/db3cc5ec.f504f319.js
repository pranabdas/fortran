"use strict";(self.webpackChunkfortran_programing=self.webpackChunkfortran_programing||[]).push([["908"],{4497:function(n,r,a){a.r(r),a.d(r,{frontMatter:()=>l,toc:()=>E,default:()=>u,metadata:()=>e,assets:()=>c,contentTitle:()=>o});var e=JSON.parse('{"id":"array","title":"Array and Matrix","description":"There is intrinsic SIZE function to determine the length of a vector, SIZE(vec).","source":"@site/docs/array.mdx","sourceDirName":".","slug":"/array","permalink":"/fortran/array","draft":false,"unlisted":false,"editUrl":"https://github.com/pranabdas/fortran/blob/main/docs/array.mdx","tags":[],"version":"current","frontMatter":{"title":"Array and Matrix"},"sidebar":"docs","previous":{"title":"Basics","permalink":"/fortran/basics"},"next":{"title":"Logical control","permalink":"/fortran/control"}}'),i=a(4848),t=a(4429),s=a(4565);let l={title:"Array and Matrix"},o=void 0,c={},E=[];function d(n){let r={a:"a",code:"code",p:"p",pre:"pre",...(0,t.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.A,{language:"fortran",title:"src/05_array.f90",showLineNumbers:!0,children:"! Program : Array\n\nPROGRAM array\n  IMPLICIT NONE\n\n  INTEGER :: vec(10)\n  INTEGER :: ii\n\n  OUTER_LOOP : DO ii = 1, 10\n    vec(ii) = ii\n  ENDDO OUTER_LOOP\n\n  DO ii = 1, 10\n    PRINT '(i2)', vec(ii)\n  ENDDO\n\nEND PROGRAM array\n"}),"\n",(0,i.jsx)(r.p,{children:"There is intrinsic SIZE function to determine the length of a vector, SIZE(vec).\nAnother example where we use implied DO loop to assign an array:"}),"\n","\n",(0,i.jsx)(s.A,{language:"fortran",title:"src/05_array2.f90",showLineNumbers:!0,children:"PROGRAM array2\n    IMPLICIT NONE\n\n    INTEGER, DIMENSION(10) :: vec\n    INTEGER :: ii\n\n    vec = [(ii, ii = 1, 10)]\n\n    DO ii = 1, SIZE(vec)\n      PRINT '(i2)', vec(ii)\n    ENDDO\n\nEND PROGRAM array2\n"}),"\n",(0,i.jsx)(r.p,{children:"Dynamic array allocation with ALLOCATABLE:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-fortran",children:"INTEGER, DIMENSION(:), ALLOCATABLE :: a\nINTEGER i\na = [(i, i = 1, 10)]\nDEALLOCATE(a)\n"})}),"\n",(0,i.jsxs)(r.p,{children:["See dynamic array allocation in ",(0,i.jsx)(r.a,{href:"inner-product",children:"this example"}),"."]}),"\n",(0,i.jsx)(r.p,{children:"Assign high dimensional array with RESHAPE:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-fortran",children:"a = RESHAPE([1, 2, 3, 4, 5, 6], [2, 3])\n! will produce\n! 1 3 5\n! 2 4 6\n\na = RESHAPE([1, 2, 3, 4, 5, 6], [2, 3], order=[2, 1])\n! will produce\n! 1 2 3\n! 4 5 6\n"})}),"\n",(0,i.jsx)(r.p,{children:"Matrix multiplication:"}),"\n","\n",(0,i.jsx)(s.A,{language:"fortran",title:"src/05_matrix_mult.f90",showLineNumbers:!0,children:"! Program : Matrix multiplication\n\nPROGRAM matrix_mult\n  IMPLICIT NONE\n\n  INTEGER, DIMENSION(2, 3) :: A = RESHAPE([1, 2, 3, &\n                                           4, 5, 6], &\n                                           shape(A), &\n                                           order=[2, 1])\n\n  INTEGER, DIMENSION(3, 2) :: B = RESHAPE([1, 2, &\n                                           3, 4, &\n                                           5, 6], &\n                                           shape(B), &\n                                           order=[2, 1])\n\n  INTEGER, DIMENSION(2, 2) :: output\n  INTEGER :: ii\n\n  output = MATMUL(A, B)\n\n  DO ii = 1, 2\n    PRINT *, output(ii, :)\n  END DO\nEND PROGRAM matrix_mult\n"}),"\n",(0,i.jsx)(r.p,{children:"You can assign all the array element same value by assigning it a scaler value:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-fortran",children:"INTEGER, DIMENSION(2, 2) :: a\na = 1\n! will produce\n! 1 1\n! 1 1\n"})})]})}function u(n={}){let{wrapper:r}={...(0,t.R)(),...n.components};return r?(0,i.jsx)(r,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}}}]);