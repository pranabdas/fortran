"use strict";(self.webpackChunkfortran_programing=self.webpackChunkfortran_programing||[]).push([[369],{5192:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var i=r(7462),t=(r(7294),r(3905)),u=r(814);const o={title:"Recursion"},c=void 0,s={unversionedId:"recursion",id:"recursion",title:"Recursion",description:"Ordinary FORTRAN procedures (subroutine and function) are not recursive, i.e.,",source:"@site/docs/recursion.mdx",sourceDirName:".",slug:"/recursion",permalink:"/fortran/recursion",draft:!1,editUrl:"https://github.com/pranabdas/fortran/blob/main/docs/recursion.mdx",tags:[],version:"current",frontMatter:{title:"Recursion"},sidebar:"docs",previous:{title:"Procedures",permalink:"/fortran/procedures"},next:{title:"Coding practice",permalink:"/fortran/category/coding-practice"}},a={},l=[{value:"Recursive subroutine",id:"recursive-subroutine",level:2},{value:"Recursive function",id:"recursive-function",level:2}],N={toc:l};function p(n){let{components:e,...r}=n;return(0,t.kt)("wrapper",(0,i.Z)({},N,r,{components:e,mdxType:"MDXLayout"}),(0,t.kt)("p",null,"Ordinary FORTRAN procedures (subroutine and function) are not recursive, i.e.,\nthey cannot invoke themselves in their body. We can use the ",(0,t.kt)("inlineCode",{parentName:"p"},"RECURSIVE")," keyword\nto implement recursive procedures."),(0,t.kt)("h2",{id:"recursive-subroutine"},"Recursive subroutine"),(0,t.kt)("p",null,"Calculate factorial using recursive subroutine:"),(0,t.kt)(u.Z,{language:"fortran",title:"src/21_recursive_subroutine.f90",showLineNumbers:!0,mdxType:"CodeBlock"},'! Calculate factorial\n!      | n(n -1)  n >= 1 \n! n! = |\n!      | 1        n = 0\nPROGRAM recursive_subroutine\n    IMPLICIT NONE\n    INTEGER :: input, output\n\n    PRINT *, "This program calculates factorial:"\n    PRINT \'(a,$)\', "Input = "\n    READ *, input\n\n    CALL factorial(input, output)\n\n    PRINT *, input, "! = ", output\n\nCONTAINS\n    RECURSIVE SUBROUTINE factorial(n, result)\n        INTEGER, INTENT(IN) :: n\n        INTEGER, INTENT(OUT) :: result\n        INTEGER :: tmp\n\n        IF (n >= 1) THEN\n            CALL factorial(n-1, tmp)\n            result = n * tmp\n        ELSE\n            result = 1\n        END IF\n    END SUBROUTINE factorial\nEND PROGRAM recursive_subroutine\n'),(0,t.kt)("h2",{id:"recursive-function"},"Recursive function"),(0,t.kt)("p",null,"Calculate fibonacci series using recursive function:"),(0,t.kt)(u.Z,{language:"fortran",title:"src/21_recursive_function.f90",showLineNumbers:!0,mdxType:"CodeBlock"},'! Fibonacci series\n! F(0) = 0\n! F(1) = 1\n! F(n) = F(n-1) + F(n-2)  for n > 1\nPROGRAM recursive_function\n    IMPLICIT NONE\n    INTEGER :: lim, i\n\n    PRINT *, "This program calculates fibonacci series:"\n    PRINT \'(a,$)\', "Limit = "\n    READ *, lim\n\n    DO i = 0, lim\n        PRINT *, "Fib(", i, ") = ", fibonacci(i)\n    END DO\n\nCONTAINS\n    RECURSIVE FUNCTION fibonacci(n) RESULT(output)\n        INTEGER, INTENT(IN) :: n\n        INTEGER :: output\n\n        IF (n > 1) THEN\n            output = fibonacci(n - 1) + fibonacci(n - 2)\n        ELSE IF (n == 1) THEN\n            output = 1\n        ELSE\n            output = 0\n        END IF\n    END FUNCTION fibonacci\nEND PROGRAM recursive_function\n'))}p.isMDXComponent=!0}}]);